<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Triangle Shader</title>
    <style>
      html,
      body {
        margin: 0;
        overflow: hidden;
        background: #888;
      }
      canvas {
        display: block;
      }
      #menu {
        position: fixed;
        bottom: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 5px;
        padding: 10px;
        font-family: sans-serif;
        display: none;
      }
      #menu input[type="range"] {
        width: 100px;
      }
      #menu label {
        display: block;
        font-size: 12px;
        margin-top: 5px;
      }
    </style>
  </head>
  <body>
    <canvas id="glcanvas"></canvas>
    <div id="menu">
      <label
        >Nombre: <input type="range" id="count" min="1" max="1000" value="10"
      /></label>
      <label
        >Taille: <input type="range" id="size" min="1" max="40" value="10"
      /></label>
      <label
        >Vitesse:
        <input type="range" id="speed" min="0" max="10" step="0.1" value="1"
      /></label>
      <label>Rotation: <input type="checkbox" id="rotate" checked /></label>
      <label
        >Couleur:
        <select id="color">
          <option value="rainbow">Rainbow</option>
          <option value="pink">Pink</option>
          <option value="blue">Blue</option>
          <option value="green">Green</option>
        </select></label
      >
      <label><button id="fullscreen">Plein Ã©cran</button></label>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
      attribute vec2 a_position;
      uniform float u_size;
      uniform float u_rotation;
      uniform vec2 u_resolution;
      void main() {
        float angle = radians(u_rotation);
        mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        vec2 pos = rot * a_position * u_size;
        vec2 zeroToOne = (pos + vec2(1.0)) * 0.5;
        vec2 zeroToCanvas = zeroToOne * u_resolution;
        vec2 clipSpace = (zeroToCanvas / u_resolution) * 2.0 - 1.0;
        gl_Position = vec4(clipSpace, 0, 1);
      }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
      precision mediump float;
      uniform vec3 u_color;
      void main() {
        gl_FragColor = vec4(u_color, 1);
      }
    </script>

    <script>
      const canvas = document.getElementById("glcanvas");
      const gl = canvas.getContext("webgl2");
      const menu = document.getElementById("menu");
      let width, height;
      let rotation = 0;

      const vsSource = document.getElementById("vertexShader").text;
      const fsSource = document.getElementById("fragmentShader").text;

      function createShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
      }

      const vertexShader = createShader(gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl.FRAGMENT_SHADER, fsSource);

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.useProgram(program);

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const triangle = [0, 0.5, -0.5, -0.5, 0.5, -0.5];
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(triangle),
        gl.STATIC_DRAW
      );

      const a_position = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(a_position);
      gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

      const u_size = gl.getUniformLocation(program, "u_size");
      const u_rotation = gl.getUniformLocation(program, "u_rotation");
      const u_resolution = gl.getUniformLocation(program, "u_resolution");
      const u_color = gl.getUniformLocation(program, "u_color");

      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        gl.viewport(0, 0, width, height);
      }
      resize();
      window.addEventListener("resize", resize);

      function getColor(name) {
        switch (name) {
          case "pink":
            return [1.0, 0.5, 0.8];
          case "blue":
            return [0.2, 0.7, 1.0];
          case "green":
            return [0.2, 1.0, 0.5];
          default:
            return [Math.random(), Math.random(), Math.random()];
        }
      }

      function drawScene() {
        gl.clearColor(0.5, 0.5, 0.5, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        const count = +document.getElementById("count").value;
        const size = +document.getElementById("size").value / 100;
        const speed = +document.getElementById("speed").value;
        const rotate = document.getElementById("rotate").checked;
        const colorName = document.getElementById("color").value;
        let color = getColor(colorName);

        gl.uniform2f(u_resolution, width, height);

        for (let i = 0; i < count; i++) {
          let angle = rotation + (i * 360) / count;
          gl.uniform1f(u_rotation, angle);
          gl.uniform1f(u_size, size);
          gl.uniform3fv(u_color, color);
          gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        if (rotate) {
          rotation += speed;
        }
        requestAnimationFrame(drawScene);
      }

      drawScene();

      canvas.addEventListener("mousemove", (e) => {
        if (
          e.clientY > window.innerHeight - 100 &&
          e.clientX > window.innerWidth - 200
        ) {
          menu.style.display = "block";
        } else {
          menu.style.display = "none";
        }
      });

      document.getElementById("fullscreen").addEventListener("click", () => {
        if (!document.fullscreenElement) {
          document.body.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      });
    </script>
  </body>
</html>
