<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Triangle Gradient</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #888;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #controls {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-family: sans-serif;
        font-size: 14px;
      }
      #controls label {
        display: block;
        margin: 5px 0 2px;
      }
    </style>
  </head>
  <body>
    <canvas id="glcanvas"></canvas>
    <div id="controls">
      <label
        >Nombre de triangles:
        <input type="range" id="numTriangles" min="1" max="1000" value="10"
      /></label>
      <label
        >Taille (% écran):
        <input type="range" id="size" min="2" max="40" value="10"
      /></label>
      <label
        >Vitesse de rotation:
        <input type="range" id="speed" min="0" max="5" step="0.1" value="1"
      /></label>
      <label
        >Couleur:
        <select id="colorGradient">
          <option value="rainbow">Arc-en-ciel</option>
          <option value="blue">Bleu</option>
          <option value="green">Vert</option>
          <option value="red">Rouge</option>
          <option value="pink">Rose</option>
          <option value="sunset">Oiseaux de Paradis</option>
        </select>
      </label>
      <button id="fullscreen">Plein écran</button>
    </div>

    <script type="module">
      const canvas = document.getElementById("glcanvas");
      const gl = canvas.getContext("webgl2");

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const vsSource = `#version 300 es
in vec2 a_position;
in vec3 a_color;
out vec3 v_color;
uniform mat3 u_rotation;
void main() {
  vec2 pos = (u_rotation * vec3(a_position, 1)).xy;
  gl_Position = vec4(pos, 0, 1);
  v_color = a_color;
}`;

      const fsSource = `#version 300 es
precision mediump float;
in vec3 v_color;
out vec4 fragColor;
void main() {
  fragColor = vec4(v_color, 1.0);
}`;

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      function createProgram(gl, vs, fs) {
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(program));
          gl.deleteProgram(program);
          return null;
        }
        return program;
      }

      const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = createProgram(gl, vs, fs);

      const aPosLoc = gl.getAttribLocation(program, "a_position");
      const aColorLoc = gl.getAttribLocation(program, "a_color");
      const uRotationLoc = gl.getUniformLocation(program, "u_rotation");

      const posBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
      const triangle = new Float32Array([0, 0.2, -0.2, -0.2, 0.2, -0.2]);
      gl.bufferData(gl.ARRAY_BUFFER, triangle, gl.STATIC_DRAW);

      const colorBuffer = gl.createBuffer();

      function getGradientColors(name) {
        switch (name) {
          case "blue":
            return [
              [0, 0, 1],
              [0, 0.5, 1],
              [0.0, 0.0, 0.2],
            ];
          case "green":
            return [
              [0, 1, 0],
              [0.6, 1, 0.4],
              [0.0, 0.3, 0.0],
            ];
          case "red":
            return [
              [1, 0, 0],
              [1, 0.6, 0.4],
              [1, 0.1, 0.1],
            ];
          case "pink":
            return [
              [1, 0, 1],
              [1, 0.6, 1],
              [1, 0.1, 1],
            ];
          case "sunset":
            return [
              [1, 0.5, 0],
              [1, 0, 0.5],
              [0.5, 0, 1],
            ];
          default: // rainbow
            return [
              [1, 0, 0],
              [0, 1, 0],
              [0, 0, 1],
            ];
        }
      }

      function randomPos(size) {
        return [
          (Math.random() * 2 - 1) * (1 - size),
          (Math.random() * 2 - 1) * (1 - size),
        ];
      }

      let rotation = 0;

      function drawScene() {
        const num = parseInt(document.getElementById("numTriangles").value);
        const size = parseInt(document.getElementById("size").value) / 100;
        const speed = parseFloat(document.getElementById("speed").value);
        const gradientName = document.getElementById("colorGradient").value;
        const gradientColors = getGradientColors(gradientName);

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0.5, 0.5, 0.5, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(program);

        gl.enableVertexAttribArray(aPosLoc);
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);

        const colorData = [];
        for (let i = 0; i < 3; i++) {
          colorData.push(...gradientColors[i]);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(colorData),
          gl.STATIC_DRAW
        );
        gl.enableVertexAttribArray(aColorLoc);
        gl.vertexAttribPointer(aColorLoc, 3, gl.FLOAT, false, 0, 0);

        rotation += 0.01 * speed;
        const cos = Math.cos(rotation);
        const sin = Math.sin(rotation);
        const rotationMatrix = [
          cos * size,
          -sin * size,
          0,
          sin * size,
          cos * size,
          0,
          0,
          0,
          1,
        ];
        gl.uniformMatrix3fv(uRotationLoc, false, rotationMatrix);

        for (let i = 0; i < num; i++) {
          const pos = randomPos(size);
          const matrix = [1, 0, pos[0], 0, 1, pos[1], 0, 0, 1];
          const finalMatrix = [
            rotationMatrix[0] * matrix[0] + rotationMatrix[1] * matrix[3],
            rotationMatrix[0] * matrix[1] + rotationMatrix[1] * matrix[4],
            rotationMatrix[0] * matrix[2] + rotationMatrix[1] * matrix[5],

            rotationMatrix[3] * matrix[0] + rotationMatrix[4] * matrix[3],
            rotationMatrix[3] * matrix[1] + rotationMatrix[4] * matrix[4],
            rotationMatrix[3] * matrix[2] + rotationMatrix[4] * matrix[5],

            0,
            0,
            1,
          ];
          gl.uniformMatrix3fv(uRotationLoc, false, finalMatrix);
          gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        requestAnimationFrame(drawScene);
      }

      document.getElementById("fullscreen").onclick = () => {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else {
          canvas.requestFullscreen();
        }
      };

      requestAnimationFrame(drawScene);
    </script>
  </body>
</html>
